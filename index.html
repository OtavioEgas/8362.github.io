<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat em Tempo Real com WebRTC e Firebase</title>
    <script src="https://www.gstatic.com/firebasejs/9.3.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.3.0/firebase-database.js"></script>
</head>
<body>

<div>
    <div>
        <label for="username">Usuário:</label>
        <input type="text" id="username">
    </div>
    <div>
        <label for="message">Mensagem:</label>
        <input type="text" id="message">
        <button onclick="sendMessage()">Enviar</button>
    </div>
    <div>
        <ul id="chat"></ul>
    </div>
</div>

<script>
    // Substitua estas configurações com as do seu projeto Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBglmUN6hylmO8xYmjQzUXjz_LaITif9bw",
        authDomain: "chat-d7975.firebaseapp.com",
        projectId: "chat-d7975",
        storageBucket: "chat-d7975.appspot.com",
        messagingSenderId: "309856740717",
        appId: "1:309856740717:web:b0807a21b06664a58ce664",
        measurementId: "G-PGML2EMEEX"
    };

    firebase.initializeApp(firebaseConfig);

    const database = firebase.database();

    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    const peerConnection = new RTCPeerConnection(configuration);
    const dataChannel = peerConnection.createDataChannel('chat');

    // Configuração da sinalização usando o Firebase
    const chatRoom = 'suaSalaDeChat'; // Substitua com um identificador único para sua sala de chat
    const chatRef = database.ref(`/chats/${chatRoom}`);

    // Adiciona os eventos para sinalização
    chatRef.on('child_added', handleSignalData);

    function handleSignalData(snapshot) {
        const signal = snapshot.val();
        if (signal) {
            if (signal.iceCandidate) {
                peerConnection.addIceCandidate(new RTCIceCandidate(signal.iceCandidate));
            } else if (signal.offer) {
                handleOffer(signal.offer);
            } else if (signal.answer) {
                handleAnswer(signal.answer);
            }
        }
    }

    function handleOffer(offer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        peerConnection.createAnswer()
            .then(answer => peerConnection.setLocalDescription(answer))
            .then(() => {
                chatRef.push({ answer: peerConnection.localDescription });
            });
    }

    function handleAnswer(answer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }

    // Adiciona lógica de sinalização ao enviar mensagem
    dataChannel.onopen = () => {
        console.log('Conexão de dados aberta.');
    };

    dataChannel.onmessage = event => {
        appendMessage(event.data);
    };

    function sendMessage() {
        const username = document.getElementById('username').value;
        const message = document.getElementById('message').value;

        if (username && message) {
            const msg = `${username}: ${message}`;
            appendMessage(msg);
            dataChannel.send(msg);
            document.getElementById('message').value = '';
        }
    }

    function appendMessage(msg) {
        const chat = document.getElementById('chat');
        const li = document.createElement('li');
        li.appendChild(document.createTextNode(msg));
        chat.appendChild(li);
    }

    // Configuração inicial
    peerConnection.createOffer()
        .then(offer => peerConnection.setLocalDescription(offer))
        .then(() => {
            chatRef.push({ offer: peerConnection.localDescription });
        });

</script>

</body>
</html>
